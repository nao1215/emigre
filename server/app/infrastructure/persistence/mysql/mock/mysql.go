// Package mock is a package for mocking MySQL.
package mock

import (
	"context"
	"database/sql"
	"errors"
	"runtime"
	"sync"

	"github.com/nao1215/emigre/server/app/domain/repository"
)

// Result is a struct that contains the result of a query.
type Result struct{}

// LastInsertId returns the integer generated by the database in response to a command.
func (*Result) LastInsertId() (int64, error) { return 0, nil }

// RowsAffected returns the number of rows affected by an update,
// insert, or delete.
func (*Result) RowsAffected() (int64, error) { return 0, nil }

// txState is a type that represents the state of a transaction.
type txState int

const (
	// txStateActive is the state of a transaction that is active.
	txStateActive txState = iota
	// txStateCommitted is the state of a transaction that is committed.
	txStateCommitted
	// txStateRolledBack is the state of a transaction that is rolled back.
	txStateRolledBack
)

// Tx is a struct that contains the settings for the transaction.
type Tx struct {
	// mu is a mutex for the transaction.
	mu sync.Mutex
	// readOnly is a flag that indicates whether the transaction is read-only.
	readOnly bool
	// txState is the state of the transaction.
	state txState
	// stack is a stack of queries.
	stack []byte
}

// ExecContext executes a query that doesn't return rows.
func (tx *Tx) ExecContext(_ context.Context, _ string, _ ...interface{}) (sql.Result, error) {
	tx.mu.Lock()
	defer tx.mu.Unlock()

	if tx.state != txStateActive {
		return nil, sql.ErrTxDone
	}
	if tx.readOnly {
		return nil, errors.New("mysql-mock: read-only transaction. cannot execute query")
	}
	return &Result{}, nil
}

// QueryContext executes a query that returns rows.
func (tx *Tx) QueryContext(_ context.Context, _ string, _ ...interface{}) (*sql.Rows, error) {
	tx.mu.Lock()
	defer tx.mu.Unlock()

	if tx.state != txStateActive {
		return nil, sql.ErrTxDone
	}
	return &sql.Rows{}, nil
}

// PrepareContext prepares a query that returns rows.
func (tx *Tx) PrepareContext(_ context.Context, _ string) (*sql.Stmt, error) {
	tx.mu.Lock()
	defer tx.mu.Unlock()

	if tx.state != txStateActive {
		return nil, sql.ErrTxDone
	}
	return &sql.Stmt{}, nil
}

// QueryRowContext executes a query that is expected to return at most one row.
func (tx *Tx) QueryRowContext(_ context.Context, _ string, _ ...interface{}) *sql.Row {
	tx.mu.Lock()
	defer tx.mu.Unlock()

	if tx.state != txStateActive {
		return nil
	}
	return &sql.Row{}
}

// Commit commits the transaction.
func (tx *Tx) Commit() error {
	tx.mu.Lock()
	defer tx.mu.Unlock()

	if tx.state != txStateActive {
		return sql.ErrTxDone
	}
	tx.state = txStateCommitted
	return nil
}

// Rollback aborts the transaction.
func (tx *Tx) Rollback() error {
	tx.mu.Lock()
	defer tx.mu.Unlock()

	if tx.state != txStateActive {
		return sql.ErrTxDone
	}
	tx.state = txStateRolledBack
	return nil
}

var _ repository.DB = (*DB)(nil)

// DB is a struct that contains the settings for the MySQL database.
type DB struct {
	mu  sync.Mutex
	txs []*Tx
}

// NewDB returns a new DB struct.
func NewDB() *DB {
	return &DB{}
}

// BeginTx begins a transaction.
func (db *DB) BeginTx(_ context.Context, opts *sql.TxOptions) (repository.Tx, error) {
	const size = 64 << 10 // 64KB
	buf := make([]byte, size)
	n := runtime.Stack(buf, false)

	tx := &Tx{
		readOnly: opts.ReadOnly,
		stack:    buf[:n],
	}

	db.mu.Lock()
	defer db.mu.Unlock()
	db.txs = append(db.txs, tx)
	return tx, nil
}

// BeginReadOnlyTx begins a read-only transaction.
func (db *DB) BeginReadOnlyTx(_ context.Context) (repository.Tx, error) {
	const size = 64 << 10 // 64KB
	buf := make([]byte, size)
	n := runtime.Stack(buf, false)

	tx := &Tx{
		readOnly: true,
		stack:    buf[:n],
	}

	db.mu.Lock()
	defer db.mu.Unlock()
	db.txs = append(db.txs, tx)
	return tx, nil
}

// Reset resets the database.
func (db *DB) Reset() {
	db.mu.Lock()
	defer db.mu.Unlock()
	db.txs = nil
}

// PrepareContext prepares a query that returns rows.
func (db *DB) PrepareContext(_ context.Context, _ string) (*sql.Stmt, error) {
	return &sql.Stmt{}, nil
}

// QueryContext executes a query that returns rows.
func (db *DB) QueryContext(_ context.Context, _ string, _ ...interface{}) (*sql.Rows, error) {
	return &sql.Rows{}, nil
}

// QueryRowContext executes a query that is expected to return at most one row.
func (db *DB) QueryRowContext(_ context.Context, _ string, _ ...interface{}) *sql.Row {
	return &sql.Row{}
}

// ExecContext executes a query that doesn't return rows.
func (db *DB) ExecContext(_ context.Context, _ string, _ ...interface{}) (sql.Result, error) {
	return &Result{}, nil
}

// Close closes the database.
func (db *DB) Close() error {
	return nil
}
